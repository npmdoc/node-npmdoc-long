<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/dcodeIO/long.js#readme"

    >long (v3.2.0)</a>
</h1>
<h4>A Long class for representing a 64-bit two's-complement integer value.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.long">module long</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.long">
            function <span class="apidocSignatureSpan"></span>long
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.fromBits">
            function <span class="apidocSignatureSpan">long.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.fromInt">
            function <span class="apidocSignatureSpan">long.</span>fromInt
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.fromNumber">
            function <span class="apidocSignatureSpan">long.</span>fromNumber
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.fromString">
            function <span class="apidocSignatureSpan">long.</span>fromString
            <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.fromValue">
            function <span class="apidocSignatureSpan">long.</span>fromValue
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index">
            function <span class="apidocSignatureSpan">long.</span>index
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.isLong">
            function <span class="apidocSignatureSpan">long.</span>isLong
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>MAX_UNSIGNED_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>UONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>UZERO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>ZERO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.</span>index.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.long.index">module long.index</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.index">
            function <span class="apidocSignatureSpan">long.</span>index
            <span class="apidocSignatureSpan">(low, high, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.fromBits">
            function <span class="apidocSignatureSpan">long.index.</span>fromBits
            <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.fromInt">
            function <span class="apidocSignatureSpan">long.index.</span>fromInt
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.fromNumber">
            function <span class="apidocSignatureSpan">long.index.</span>fromNumber
            <span class="apidocSignatureSpan">(value, unsigned)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.fromString">
            function <span class="apidocSignatureSpan">long.index.</span>fromString
            <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.fromValue">
            function <span class="apidocSignatureSpan">long.index.</span>fromValue
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.isLong">
            function <span class="apidocSignatureSpan">long.index.</span>isLong
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>MAX_UNSIGNED_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>MAX_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>MIN_VALUE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>NEG_ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>ONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>UONE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>UZERO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">long.index.</span>ZERO</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.long.index.prototype">module long.index.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.add">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>add
            <span class="apidocSignatureSpan">(addend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.and">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>and
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.comp">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>comp
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.compare">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>compare
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.div">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>div
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.divide">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>divide
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.eq">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>eq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.equals">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>equals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.getHighBits">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>getHighBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.getHighBitsUnsigned">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>getHighBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.getLowBits">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>getLowBits
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.getLowBitsUnsigned">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>getLowBitsUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.getNumBitsAbs">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>getNumBitsAbs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.greaterThan">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>greaterThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.greaterThanOrEqual">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>greaterThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.gt">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>gt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.gte">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>gte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.isEven">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>isEven
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.isNegative">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>isNegative
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.isOdd">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>isOdd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.isPositive">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>isPositive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.isZero">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>isZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.lessThan">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>lessThan
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.lessThanOrEqual">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>lessThanOrEqual
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.lt">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>lt
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.lte">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>lte
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.mod">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>mod
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.modulo">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>modulo
            <span class="apidocSignatureSpan">(divisor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.mul">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>mul
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.multiply">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>multiply
            <span class="apidocSignatureSpan">(multiplier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.neg">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>neg
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.negate">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>negate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.neq">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>neq
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.not">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.notEquals">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>notEquals
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.or">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>or
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shiftLeft">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftLeft
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shiftRight">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftRight
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shiftRightUnsigned">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftRightUnsigned
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shl">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shl
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shr">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shr
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.shru">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>shru
            <span class="apidocSignatureSpan">(numBits)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.sub">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>sub
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.subtract">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>subtract
            <span class="apidocSignatureSpan">(subtrahend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toBytes">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytes
            <span class="apidocSignatureSpan">(le)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toBytesBE">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytesBE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toBytesLE">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytesLE
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toInt">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toInt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toNumber">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toNumber
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toSigned">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toSigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toString">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toString
            <span class="apidocSignatureSpan">(radix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.toUnsigned">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>toUnsigned
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.long.index.prototype.xor">
            function <span class="apidocSignatureSpan">long.index.prototype.</span>xor
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.long" id="apidoc.module.long">module long</a></h1>


    <h2>
        <a href="#apidoc.element.long.long" id="apidoc.element.long.long">
        function <span class="apidocSignatureSpan"></span>long
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.fromBits" id="apidoc.element.long.fromBits">
        function <span class="apidocSignatureSpan">long.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signed zero.

|                 |                 |
|-----------------|-----------------|
| **@type**       | *!Long*         |

#### Long.<span class="apidocCodeKeywordSpan">fromBits</span>(lowBits, highBits, unsigned=)

Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
assumed to use 32 bits.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| lowBits         | *number*        | The low 32 bits
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.fromInt" id="apidoc.element.long.fromInt">
        function <span class="apidocSignatureSpan">long.</span>fromInt
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value &#x3e;&#x3e;&#x3e;= 0;
        if (cache = (0 &#x3c;= value &#x26;&#x26; value &#x3c; 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) &#x3c; 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 &#x3c;= value &#x26;&#x26; value &#x3c; 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value &#x3c; 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| lowBits         | *number*        | The low 32 bits
| highBits        | *number*        | The high 32 bits
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromInt</span>(value, unsigned=)

Returns a Long representing the given 32 bit integer value.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The 32 bit integer in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.fromNumber" id="apidoc.element.long.fromNumber">
        function <span class="apidocSignatureSpan">long.</span>fromNumber
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromNumber(value, unsigned) {
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value &#x3c; 0)
            return UZERO;
        if (value &#x3e;= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value &#x3c;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &#x3e;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &#x3c; 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The 32 bit integer in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromNumber</span>(value, unsigned=)

Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The number in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.fromString" id="apidoc.element.long.fromString">
        function <span class="apidocSignatureSpan">long.</span>fromString
        <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error(&#x27;empty string&#x27;);
    if (str === &#x22;NaN&#x22; || str === &#x22;Infinity&#x22; || str === &#x22;+Infinity&#x22; || str === &#x22;-Infinity&#x22;)
        return ZERO;
    if (typeof unsigned === &#x27;number&#x27;) {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix &#x3c; 2 || 36 &#x3c; radix)
        throw RangeError(&#x27;radix&#x27;);

    var p;
    if ((p = str.indexOf(&#x27;-&#x27;)) &#x3e; 0)
        throw Error(&#x27;interior hyphen&#x27;);
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i &#x3c; str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size &#x3c; 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The number in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromString</span>(str, unsigned=, radix=)

Returns a Long representation of the given string, written using the specified radix.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| str             | *string*        | The textual representation of the Long
| unsigned        | *boolean &#x26;#124; number* | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.fromValue" id="apidoc.element.long.fromValue">
        function <span class="apidocSignatureSpan">long.</span>fromValue
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromValue(val) {
    if (val /* is compatible */ instanceof Long)
        return val;
    if (typeof val === &#x27;number&#x27;)
        return fromNumber(val);
    if (typeof val === &#x27;string&#x27;)
        return fromString(val);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, val.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Tests if the specified object is a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| obj             | ***             | Object
| **@returns**    | *boolean*       |

#### Long.<span class="apidocCodeKeywordSpan">fromValue</span>(val)

Converts the specified value to a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| val             | *!Long &#x26;#124; number &#x26;#124; string &#x26;#124; !{low: number, high: number, unsigned: boolean}* |
Value
| **@returns**    | *!Long*         |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index" id="apidoc.element.long.index">
        function <span class="apidocSignatureSpan">long.</span>index
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.isLong" id="apidoc.element.long.isLong">
        function <span class="apidocSignatureSpan">long.</span>isLong
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLong(obj) {
    return (obj &#x26;&#x26; obj[&#x22;__isLong__&#x22;]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| str             | *string*        | The textual representation of the Long
| unsigned        | *boolean &#x26;#124; number* | Whether unsigned or not, defaults to `false` for signed
| radix           | *number*        | The radix in which the text is written (2-36), defaults to 10
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">isLong</span>(obj)

Tests if the specified object is a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| obj             | ***             | Object
| **@returns**    | *boolean*       |
...</pre></li>
    </ul>




















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.long.index" id="apidoc.module.long.index">module long.index</a></h1>


    <h2>
        <a href="#apidoc.element.long.index.index" id="apidoc.element.long.index.index">
        function <span class="apidocSignatureSpan">long.</span>index
        <span class="apidocSignatureSpan">(low, high, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.fromBits" id="apidoc.element.long.index.fromBits">
        function <span class="apidocSignatureSpan">long.index.</span>fromBits
        <span class="apidocSignatureSpan">(lowBits, highBits, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Signed zero.

|                 |                 |
|-----------------|-----------------|
| **@type**       | *!Long*         |

#### Long.<span class="apidocCodeKeywordSpan">fromBits</span>(lowBits, highBits, unsigned=)

Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
assumed to use 32 bits.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| lowBits         | *number*        | The low 32 bits
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.fromInt" id="apidoc.element.long.index.fromInt">
        function <span class="apidocSignatureSpan">long.index.</span>fromInt
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value &#x3e;&#x3e;&#x3e;= 0;
        if (cache = (0 &#x3c;= value &#x26;&#x26; value &#x3c; 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) &#x3c; 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 &#x3c;= value &#x26;&#x26; value &#x3c; 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value &#x3c; 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| lowBits         | *number*        | The low 32 bits
| highBits        | *number*        | The high 32 bits
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromInt</span>(value, unsigned=)

Returns a Long representing the given 32 bit integer value.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The 32 bit integer in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.fromNumber" id="apidoc.element.long.index.fromNumber">
        function <span class="apidocSignatureSpan">long.index.</span>fromNumber
        <span class="apidocSignatureSpan">(value, unsigned)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromNumber(value, unsigned) {
    if (isNaN(value) || !isFinite(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value &#x3c; 0)
            return UZERO;
        if (value &#x3e;= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value &#x3c;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &#x3e;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &#x3c; 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The 32 bit integer in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromNumber</span>(value, unsigned=)

Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The number in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.fromString" id="apidoc.element.long.index.fromString">
        function <span class="apidocSignatureSpan">long.index.</span>fromString
        <span class="apidocSignatureSpan">(str, unsigned, radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error(&#x27;empty string&#x27;);
    if (str === &#x22;NaN&#x22; || str === &#x22;Infinity&#x22; || str === &#x22;+Infinity&#x22; || str === &#x22;-Infinity&#x22;)
        return ZERO;
    if (typeof unsigned === &#x27;number&#x27;) {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix &#x3c; 2 || 36 &#x3c; radix)
        throw RangeError(&#x27;radix&#x27;);

    var p;
    if ((p = str.indexOf(&#x27;-&#x27;)) &#x3e; 0)
        throw Error(&#x27;interior hyphen&#x27;);
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i &#x3c; str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size &#x3c; 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| value           | *number*        | The number in question
| unsigned        | *boolean*       | Whether unsigned or not, defaults to `false` for signed
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">fromString</span>(str, unsigned=, radix=)

Returns a Long representation of the given string, written using the specified radix.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| str             | *string*        | The textual representation of the Long
| unsigned        | *boolean &#x26;#124; number* | Whether unsigned or not, defaults to `false` for signed
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.fromValue" id="apidoc.element.long.index.fromValue">
        function <span class="apidocSignatureSpan">long.index.</span>fromValue
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fromValue(val) {
    if (val /* is compatible */ instanceof Long)
        return val;
    if (typeof val === &#x27;number&#x27;)
        return fromNumber(val);
    if (typeof val === &#x27;string&#x27;)
        return fromString(val);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, val.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Tests if the specified object is a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| obj             | ***             | Object
| **@returns**    | *boolean*       |

#### Long.<span class="apidocCodeKeywordSpan">fromValue</span>(val)

Converts the specified value to a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| val             | *!Long &#x26;#124; number &#x26;#124; string &#x26;#124; !{low: number, high: number, unsigned: boolean}* |
Value
| **@returns**    | *!Long*         |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.isLong" id="apidoc.element.long.index.isLong">
        function <span class="apidocSignatureSpan">long.index.</span>isLong
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isLong(obj) {
    return (obj &#x26;&#x26; obj[&#x22;__isLong__&#x22;]) === true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| str             | *string*        | The textual representation of the Long
| unsigned        | *boolean &#x26;#124; number* | Whether unsigned or not, defaults to `false` for signed
| radix           | *number*        | The radix in which the text is written (2-36), defaults to 10
| **@returns**    | *!Long*         | The corresponding Long value

#### Long.<span class="apidocCodeKeywordSpan">isLong</span>(obj)

Tests if the specified object is a Long.

| Parameter       | Type            | Description
|-----------------|-----------------|---------------
| obj             | ***             | Object
| **@returns**    | *boolean*       |
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.long.index.prototype" id="apidoc.module.long.index.prototype">module long.index.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.long.index.prototype.add" id="apidoc.element.long.index.prototype.add">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>add
        <span class="apidocSignatureSpan">(addend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high &#x3e;&#x3e;&#x3e; 16;
    var a32 = this.high &#x26; 0xFFFF;
    var a16 = this.low &#x3e;&#x3e;&#x3e; 16;
    var a00 = this.low &#x26; 0xFFFF;

    var b48 = addend.high &#x3e;&#x3e;&#x3e; 16;
    var b32 = addend.high &#x26; 0xFFFF;
    var b16 = addend.low &#x3e;&#x3e;&#x3e; 16;
    var b00 = addend.low &#x26; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 &#x3e;&#x3e;&#x3e; 16;
    c00 &#x26;= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 &#x3e;&#x3e;&#x3e; 16;
    c16 &#x26;= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c48 += a48 + b48;
    c48 &#x26;= 0xFFFF;
    return fromBits((c16 &#x3c;&#x3c; 16) | c00, (c48 &#x3c;&#x3c; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var result = ZERO;
for (var i = 0; i &#x3c; str.length; i += 8) {
    var size = Math.min(8, str.length - i),
        value = parseInt(str.substring(i, i + size), radix);
    if (size &#x3c; 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.mul(power).<span class="apidocCodeKeywordSpan">add</span>(fromNumber(value));
    } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
    }
}
result.unsigned = unsigned;
return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.and" id="apidoc.element.long.index.prototype.and">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>and
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low &#x26; other.low, this.high &#x26; other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.comp" id="apidoc.element.long.index.prototype.comp">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>comp
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &#x26;&#x26; !otherNeg)
        return -1;
    if (!thisNeg &#x26;&#x26; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &#x3e;&#x3e;&#x3e; 0) &#x3e; (this.high &#x3e;&#x3e;&#x3e; 0) || (other.high === this.high &#x26;&#x26; (other.low &#x3e;&#x3e;&#x3e; 0) &#x3e; (this.low &#x3e;&#x3e;&#x3e; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Tests if this Long&#x27;s value is less than the specified&#x27;s.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.<span class="apidocCodeKeywordSpan">comp</span>(/* validates */ other) &#x3c; 0;
};

/**
 * Tests if this Long&#x27;s value is less than the specified&#x27;s. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.compare" id="apidoc.element.long.index.prototype.compare">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>compare
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg &#x26;&#x26; !otherNeg)
        return -1;
    if (!thisNeg &#x26;&#x26; otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high &#x3e;&#x3e;&#x3e; 0) &#x3e; (this.high &#x3e;&#x3e;&#x3e; 0) || (other.high === this.high &#x26;&#x26; (other.low &#x3e;&#x3e;&#x3e; 0) &#x3e; (this.low &#x3e;&#x3e;&#x3e; 0)) ? -1 : 1
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/**
* @param {goog.math.Long} other Long to compare against.
* @return {boolean} Whether this Long is less than the other.
*/
goog.math.Long.prototype.lessThan = function(other) {
   return this.<span class="apidocCodeKeywordSpan">compare</span>(other) &#x3c; 0;
};


/**
* @param {goog.math.Long} other Long to compare against.
* @return {boolean} Whether this Long is less than or equal to the other.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.div" id="apidoc.element.long.index.prototype.div">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>div
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error(&#x27;division by zero&#x27;);
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It&#x27;s therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &#x3e;&#x3e;&#x3e; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &#x3c;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can&#x27;t be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isZero())
    return &#x27;0&#x27;;
if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.<span class="apidocCodeKeywordSpan">div</span>(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
    } else
        return &#x27;-&#x27; + this.neg().toString(radix);
}

// Do several (6) digits each time through the loop, so as to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.divide" id="apidoc.element.long.index.prototype.divide">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>divide
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error(&#x27;division by zero&#x27;);
    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It&#x27;s therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 &#x3e;&#x3e;&#x3e; 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 &#x3c;= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can&#x27;t be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.eq" id="apidoc.element.long.index.prototype.eq">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>eq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &#x26;&#x26; (this.high &#x3e;&#x3e;&#x3e; 31) === 1 &#x26;&#x26; (other.high &#x3e;&#x3e;&#x3e; 31) === 1)
        return false;
    return this.high === other.high &#x26;&#x26; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    LongPrototype.toString = function toString(radix) {
radix = radix || 10;
if (radix &#x3c; 2 || 36 &#x3c; radix)
    throw RangeError(&#x27;radix&#x27;);
if (this.isZero())
    return &#x27;0&#x27;;
if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.<span class="apidocCodeKeywordSpan">eq</span>(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
    } else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.equals" id="apidoc.element.long.index.prototype.equals">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>equals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned &#x26;&#x26; (this.high &#x3e;&#x3e;&#x3e; 31) === 1 &#x26;&#x26; (other.high &#x3e;&#x3e;&#x3e; 31) === 1)
        return false;
    return this.high === other.high &#x26;&#x26; this.low === other.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (this.isZero()) {
    return &#x27;0&#x27;;
}

if (this.isNegative()) {
    if (this.<span class="apidocCodeKeywordSpan">equals</span>(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).subtract(this);
        return div.toString(radix) + rem.toInt().toString(radix);
    } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.getHighBits" id="apidoc.element.long.index.prototype.getHighBits">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>getHighBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBits() {
    return this.high;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.getHighBitsUnsigned" id="apidoc.element.long.index.prototype.getHighBitsUnsigned">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>getHighBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getHighBitsUnsigned() {
    return this.high &#x3e;&#x3e;&#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.getLowBits" id="apidoc.element.long.index.prototype.getLowBits">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>getLowBits
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBits() {
    return this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.getLowBitsUnsigned" id="apidoc.element.long.index.prototype.getLowBitsUnsigned">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>getLowBitsUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getLowBitsUnsigned() {
    return this.low &#x3e;&#x3e;&#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   return this.low_;
};


/** @return {number} The closest floating-point representation to this value. */
goog.math.Long.prototype.toNumber = function() {
   return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +
       this.<span class="apidocCodeKeywordSpan">getLowBitsUnsigned</span>();
};


/**
* @param {number=} opt_radix The radix in which the text should be written.
* @return {string} The textual representation of this value.
* @override
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.getNumBitsAbs" id="apidoc.element.long.index.prototype.getNumBitsAbs">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>getNumBitsAbs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit &#x3e; 0; bit--)
        if ((val &#x26; (1 &#x3c;&#x3c; bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().<span class="apidocCodeKeywordSpan">getNumBitsAbs</span>();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit &#x3e; 0; bit--)
        if ((val &#x26; (1 &#x3c;&#x3c; bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.greaterThan" id="apidoc.element.long.index.prototype.greaterThan">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>greaterThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
var delta = (log2 &#x3c;= 48) ? 1 : Math.pow(2, log2 - 48);

// Decrease the approximation until it is smaller than the remainder.  Note
// that if it is too large, the product overflows and is negative.
var approxRes = goog.math.Long.fromNumber(approx);
var approxRem = approxRes.multiply(other);
while (approxRem.isNegative() || approxRem.<span class="apidocCodeKeywordSpan">greaterThan</span>(rem)) {
    approx -= delta;
    approxRes = goog.math.Long.fromNumber(approx);
    approxRem = approxRes.multiply(other);
}

// We know the answer can&#x27;t be zero... and actually, zero would cause
// infinite recursion since we would make no progress.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.greaterThanOrEqual" id="apidoc.element.long.index.prototype.greaterThanOrEqual">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>greaterThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    var res = goog.math.Long.ZERO;
    var rem = this;
    while (rem.<span class="apidocCodeKeywordSpan">greaterThanOrEqual</span>(other)) {
// Approximate the result of division. This may be a little greater or
// smaller than the actual value.
var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

// We will tweak the approximate result by changing it in the 48-th digit or
// the smallest non-fractional digit, whichever is larger.
var log2 = Math.ceil(Math.log(approx) / Math.LN2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.gt" id="apidoc.element.long.index.prototype.gt">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>gt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThan(other) {
    return this.comp(/* validates */ other) &#x3e; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return this.div(divisor.neg()).neg();
    res = ZERO;
} else {
    // The algorithm below has not been made for unsigned longs. It&#x27;s therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
    if (divisor.<span class="apidocCodeKeywordSpan">gt</span>(this))
        return UZERO;
    if (divisor.gt(this.shru(1))) // 15 &#x3e;&#x3e;&#x3e; 1 = 7 ; with divisor = 8 ; true
        return UONE;
    res = UZERO;
}

// Repeat the following until the remainder is less than other:  find a
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.gte" id="apidoc.element.long.index.prototype.gte">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>gte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.<span class="apidocCodeKeywordSpan">gte</span>(divisor)) {
// Approximate the result of division. This may be a little greater or
// smaller than the actual value.
approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

// We will tweak the approximate result by changing it in the 48-th digit or
// the smallest non-fractional digit, whichever is larger.
var log2 = Math.ceil(Math.log(approx) / Math.LN2),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.isEven" id="apidoc.element.long.index.prototype.isEven">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>isEven
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isEven() {
    return (this.low &#x26; 1) === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.isNegative" id="apidoc.element.long.index.prototype.isNegative">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>isNegative
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isNegative() {
    return !this.unsigned &#x26;&#x26; this.high &#x3c; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix &#x3c; 2 || 36 &#x3c; radix)
        throw RangeError(&#x27;radix&#x27;);
    if (this.isZero())
        return &#x27;0&#x27;;
    if (this.<span class="apidocCodeKeywordSpan">isNegative</span>()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.isOdd" id="apidoc.element.long.index.prototype.isOdd">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>isOdd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isOdd() {
    return (this.low &#x26; 1) === 1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isZero())
    return ZERO;
if (!isLong(multiplier))
    multiplier = fromValue(multiplier);
if (multiplier.isZero())
    return ZERO;
if (this.eq(MIN_VALUE))
    return multiplier.<span class="apidocCodeKeywordSpan">isOdd</span>() ? MIN_VALUE : ZERO;
if (multiplier.eq(MIN_VALUE))
    return this.isOdd() ? MIN_VALUE : ZERO;

if (this.isNegative()) {
    if (multiplier.isNegative())
        return this.neg().mul(multiplier.neg());
    else
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.isPositive" id="apidoc.element.long.index.prototype.isPositive">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>isPositive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isPositive() {
    return this.unsigned || this.high &#x3e;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.isZero" id="apidoc.element.long.index.prototype.isZero">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>isZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isZero() {
    return this.high === 0 &#x26;&#x26; this.low === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix &#x3c; 2 || 36 &#x3c; radix)
        throw RangeError(&#x27;radix&#x27;);
    if (this.<span class="apidocCodeKeywordSpan">isZero</span>())
        return &#x27;0&#x27;;
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.lessThan" id="apidoc.element.long.index.prototype.lessThan">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>lessThan
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &#x3c; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return this.negate().multiply(other).negate();
    }
} else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
}

// If both longs are small, use float multiplication
if (this.<span class="apidocCodeKeywordSpan">lessThan</span>(goog.math.Long.TWO_PWR_24_) &#x26;&#x26;
    other.lessThan(goog.math.Long.TWO_PWR_24_)) {
    return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());
}

// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
// We can skip products that would overflow.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.lessThanOrEqual" id="apidoc.element.long.index.prototype.lessThanOrEqual">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>lessThanOrEqual
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &#x3c;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.lt" id="apidoc.element.long.index.prototype.lt">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>lt
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThan(other) {
    return this.comp(/* validates */ other) &#x3c; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        return this.neg().mul(multiplier.neg());
    else
        return this.neg().mul(multiplier).neg();
} else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();

// If both longs are small, use float multiplication
if (this.<span class="apidocCodeKeywordSpan">lt</span>(TWO_PWR_24) &#x26;&#x26; multiplier.lt(TWO_PWR_24))
    return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
// We can skip products that would overflow.

var a48 = this.high &#x3e;&#x3e;&#x3e; 16;
var a32 = this.high &#x26; 0xFFFF;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.lte" id="apidoc.element.long.index.prototype.lte">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>lte
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) &#x3c;= 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.mod" id="apidoc.element.long.index.prototype.mod">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>mod
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.modulo" id="apidoc.element.long.index.prototype.modulo">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>modulo
        <span class="apidocSignatureSpan">(divisor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    return this.sub(this.div(divisor).mul(divisor));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.mul" id="apidoc.element.long.index.prototype.mul">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>mul
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &#x26;&#x26; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &#x3e;&#x3e;&#x3e; 16;
    var a32 = this.high &#x26; 0xFFFF;
    var a16 = this.low &#x3e;&#x3e;&#x3e; 16;
    var a00 = this.low &#x26; 0xFFFF;

    var b48 = multiplier.high &#x3e;&#x3e;&#x3e; 16;
    var b32 = multiplier.high &#x26; 0xFFFF;
    var b16 = multiplier.low &#x3e;&#x3e;&#x3e; 16;
    var b00 = multiplier.low &#x26; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &#x3e;&#x3e;&#x3e; 16;
    c00 &#x26;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &#x3e;&#x3e;&#x3e; 16;
    c16 &#x26;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &#x3e;&#x3e;&#x3e; 16;
    c16 &#x26;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &#x26;= 0xFFFF;
    return fromBits((c16 &#x3c;&#x3c; 16) | c00, (c48 &#x3c;&#x3c; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var result = ZERO;
for (var i = 0; i &#x3c; str.length; i += 8) {
    var size = Math.min(8, str.length - i),
        value = parseInt(str.substring(i, i + size), radix);
    if (size &#x3c; 8) {
        var power = fromNumber(pow_dbl(radix, size));
        result = result.<span class="apidocCodeKeywordSpan">mul</span>(power).add(fromNumber(value));
    } else {
        result = result.mul(radixToPower);
        result = result.add(fromNumber(value));
    }
}
result.unsigned = unsigned;
return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.multiply" id="apidoc.element.long.index.prototype.multiply">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>multiply
        <span class="apidocSignatureSpan">(multiplier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) &#x26;&#x26; multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high &#x3e;&#x3e;&#x3e; 16;
    var a32 = this.high &#x26; 0xFFFF;
    var a16 = this.low &#x3e;&#x3e;&#x3e; 16;
    var a00 = this.low &#x26; 0xFFFF;

    var b48 = multiplier.high &#x3e;&#x3e;&#x3e; 16;
    var b32 = multiplier.high &#x26; 0xFFFF;
    var b16 = multiplier.low &#x3e;&#x3e;&#x3e; 16;
    var b00 = multiplier.low &#x26; 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 &#x3e;&#x3e;&#x3e; 16;
    c00 &#x26;= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 &#x3e;&#x3e;&#x3e; 16;
    c16 &#x26;= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 &#x3e;&#x3e;&#x3e; 16;
    c16 &#x26;= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 &#x3e;&#x3e;&#x3e; 16;
    c32 &#x26;= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &#x26;= 0xFFFF;
    return fromBits((c16 &#x3c;&#x3c; 16) | c00, (c48 &#x3c;&#x3c; 16) | c32, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    var result = goog.math.Long.ZERO;
    for (var i = 0; i &#x3c; str.length; i += 8) {
        var size = Math.min(8, str.length - i);
        var value = parseInt(str.substring(i, i + size), radix);
        if (size &#x3c; 8) {
            var power = goog.math.Long.fromNumber(Math.pow(radix, size));
            result = result.<span class="apidocCodeKeywordSpan">multiply</span>(power).add(goog.math.Long.fromNumber(value));
        } else {
            result = result.multiply(radixToPower);
            result = result.add(goog.math.Long.fromNumber(value));
        }
    }
    return result;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.neg" id="apidoc.element.long.index.prototype.neg">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>neg
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &#x26;&#x26; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else {
        if (value &#x3c;= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 &#x3e;= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value &#x3c; 0)
        return fromNumber(-value, unsigned).<span class="apidocCodeKeywordSpan">neg</span>();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.negate" id="apidoc.element.long.index.prototype.negate">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>negate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function negate() {
    if (!this.unsigned &#x26;&#x26; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (isNaN(value) || !isFinite(value)) {
        return goog.math.Long.ZERO;
    } else if (value &#x3c;= -goog.math.Long.TWO_PWR_63_DBL_) {
        return goog.math.Long.MIN_VALUE;
    } else if (value + 1 &#x3e;= goog.math.Long.TWO_PWR_63_DBL_) {
        return goog.math.Long.MAX_VALUE;
    } else if (value &#x3c; 0) {
        return goog.math.Long.fromNumber(-value).<span class="apidocCodeKeywordSpan">negate</span>();
    } else {
        return new goog.math.Long(
            (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,
            (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);
    }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.neq" id="apidoc.element.long.index.prototype.neq">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>neq
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.not" id="apidoc.element.long.index.prototype.not">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Negates this Long&#x27;s value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned &#x26;&#x26; this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.<span class="apidocCodeKeywordSpan">not</span>().add(ONE);
};

/**
 * Negates this Long&#x27;s value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.notEquals" id="apidoc.element.long.index.prototype.notEquals">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>notEquals
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function notEquals(other) {
    return !this.eq(/* validates */ other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var longVal = Long.MIN_VALUE.div(Long.ONE);
    test.strictEqual(longVal.toString(), Long.MIN_VALUE.toString());
    test.done();
},

&#x22;msb_unsigned&#x22;: function(test) {
    var longVal = Long.UONE.shiftLeft(63);
    test.ok(longVal.<span class="apidocCodeKeywordSpan">notEquals</span>(Long.MIN_VALUE));
    test.equal(longVal.toString(), &#x22;9223372036854775808&#x22;);
    test.equal(Long.fromString(&#x22;9223372036854775808&#x22;, true).toString(), &#x22;9223372036854775808&#x22;);
    test.done();
},

&#x22;issue31&#x22;: function(test) {
    var a = new Long(0, 8, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.or" id="apidoc.element.long.index.prototype.or">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>or
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shiftLeft" id="apidoc.element.long.index.prototype.shiftLeft">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftLeft
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &#x26;= 63) === 0)
        return this;
    else if (numBits &#x3c; 32)
        return fromBits(this.low &#x3c;&#x3c; numBits, (this.high &#x3c;&#x3c; numBits) | (this.low &#x3e;&#x3e;&#x3e; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &#x3c;&#x3c; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    other.equals(goog.math.Long.NEG_ONE)) {
    return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
} else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.ONE;
} else {
    // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
    var halfThis = this.shiftRight(1);
    var approx = halfThis.div(other).<span class="apidocCodeKeywordSpan">shiftLeft</span>(1);
    if (approx.equals(goog.math.Long.ZERO)) {
        return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
    } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shiftRight" id="apidoc.element.long.index.prototype.shiftRight">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftRight
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &#x26;= 63) === 0)
        return this;
    else if (numBits &#x3c; 32)
        return fromBits((this.low &#x3e;&#x3e;&#x3e; numBits) | (this.high &#x3c;&#x3c; (32 - numBits)), this.high &#x3e;&#x3e; numBits, this.unsigned);
    else
        return fromBits(this.high &#x3e;&#x3e; (numBits - 32), this.high &#x3e;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (other.equals(goog.math.Long.ONE) ||
    other.equals(goog.math.Long.NEG_ONE)) {
    return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
} else if (other.equals(goog.math.Long.MIN_VALUE)) {
    return goog.math.Long.ONE;
} else {
    // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
    var halfThis = this.<span class="apidocCodeKeywordSpan">shiftRight</span>(1);
    var approx = halfThis.div(other).shiftLeft(1);
    if (approx.equals(goog.math.Long.ZERO)) {
        return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;
    } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shiftRightUnsigned" id="apidoc.element.long.index.prototype.shiftRightUnsigned">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shiftRightUnsigned
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &#x26;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &#x3c; 32) {
            var low = this.low;
            return fromBits((low &#x3e;&#x3e;&#x3e; numBits) | (high &#x3c;&#x3c; (32 - numBits)), high &#x3e;&#x3e;&#x3e; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &#x3e;&#x3e;&#x3e; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shl" id="apidoc.element.long.index.prototype.shl">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shl
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &#x26;= 63) === 0)
        return this;
    else if (numBits &#x3c; 32)
        return fromBits(this.low &#x3c;&#x3c; numBits, (this.high &#x3c;&#x3c; numBits) | (this.low &#x3e;&#x3e;&#x3e; (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low &#x3c;&#x3c; (numBits - 32), this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
else if (divisor.eq(MIN_VALUE))
    return ONE;
else {
    // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
    var halfThis = this.shr(1);
    approx = halfThis.div(divisor).<span class="apidocCodeKeywordSpan">shl</span>(1);
    if (approx.eq(ZERO)) {
        return divisor.isNegative() ? ONE : NEG_ONE;
    } else {
        rem = this.sub(divisor.mul(approx));
        res = approx.add(rem.div(divisor));
        return res;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shr" id="apidoc.element.long.index.prototype.shr">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shr
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &#x26;= 63) === 0)
        return this;
    else if (numBits &#x3c; 32)
        return fromBits((this.low &#x3e;&#x3e;&#x3e; numBits) | (this.high &#x3c;&#x3c; (32 - numBits)), this.high &#x3e;&#x3e; numBits, this.unsigned);
    else
        return fromBits(this.high &#x3e;&#x3e; (numBits - 32), this.high &#x3e;= 0 ? 0 : -1, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            if (this.eq(MIN_VALUE)) {
if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
else if (divisor.eq(MIN_VALUE))
    return ONE;
else {
    // At this point, we have |other| &#x3e;= 2, so |this/other| &#x3c; |MIN_VALUE|.
    var halfThis = this.<span class="apidocCodeKeywordSpan">shr</span>(1);
    approx = halfThis.div(divisor).shl(1);
    if (approx.eq(ZERO)) {
        return divisor.isNegative() ? ONE : NEG_ONE;
    } else {
        rem = this.sub(divisor.mul(approx));
        res = approx.add(rem.div(divisor));
        return res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.shru" id="apidoc.element.long.index.prototype.shru">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>shru
        <span class="apidocSignatureSpan">(numBits)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &#x26;= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits &#x3c; 32) {
            var low = this.low;
            return fromBits((low &#x3e;&#x3e;&#x3e; numBits) | (high &#x3c;&#x3c; (32 - numBits)), high &#x3e;&#x3e;&#x3e; numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high &#x3e;&#x3e;&#x3e; (numBits - 32), 0, this.unsigned);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else {
    // The algorithm below has not been made for unsigned longs. It&#x27;s therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned)
        divisor = divisor.toUnsigned();
    if (divisor.gt(this))
        return UZERO;
    if (divisor.gt(this.<span class="apidocCodeKeywordSpan">shru</span>(1))) // 15 &#x3e;&#x3e;&#x3e; 1 = 7 ; with divisor = 8 ;
true
        return UONE;
    res = UZERO;
}

// Repeat the following until the remainder is less than other:  find a
// floating-point that approximates remainder / other *from below*, add this
// into the result, and subtract it from the remainder.  It is critical that
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.sub" id="apidoc.element.long.index.prototype.sub">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>sub
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return &#x27;0&#x27;;
if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).<span class="apidocCodeKeywordSpan">sub</span>(this);
        return div.toString(radix) + rem1.toInt().toString(radix);
    } else
        return &#x27;-&#x27; + this.neg().toString(radix);
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.subtract" id="apidoc.element.long.index.prototype.subtract">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>subtract
        <span class="apidocSignatureSpan">(subtrahend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (this.isNegative()) {
    if (this.equals(goog.math.Long.MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = goog.math.Long.fromNumber(radix);
        var div = this.div(radixLong);
        var rem = div.multiply(radixLong).<span class="apidocCodeKeywordSpan">subtract</span>(this);
        return div.toString(radix) + rem.toInt().toString(radix);
    } else {
        return &#x27;-&#x27; + this.negate().toString(radix);
    }
}

// Do several (6) digits each time through the loop, so as to
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toBytes" id="apidoc.element.long.index.prototype.toBytes">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytes
        <span class="apidocSignatureSpan">(le)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytes = function (le) {
    return le ? this.toBytesLE() : this.toBytesBE();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toBytesBE" id="apidoc.element.long.index.prototype.toBytesBE">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytesBE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesBE = function () {
    var hi = this.high,
        lo = this.low;
    return [
        (hi &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff,
        (hi &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff,
        (hi &#x3e;&#x3e;&#x3e;  8) &#x26; 0xff,
         hi         &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e;  8) &#x26; 0xff,
         lo         &#x26; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.&#x3c;number&#x3e;} Byte representation
 */
LongPrototype.toBytes = function(le) {
    return le ? this.toBytesLE() : this.<span class="apidocCodeKeywordSpan">toBytesBE</span>();
}

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.&#x3c;number&#x3e;} Little endian byte representation
 */
LongPrototype.toBytesLE = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toBytesLE" id="apidoc.element.long.index.prototype.toBytesLE">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toBytesLE
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBytesLE = function () {
    var hi = this.high,
        lo = this.low;
    return [
         lo         &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e;  8) &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff,
        (lo &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff,
         hi         &#x26; 0xff,
        (hi &#x3e;&#x3e;&#x3e;  8) &#x26; 0xff,
        (hi &#x3e;&#x3e;&#x3e; 16) &#x26; 0xff,
        (hi &#x3e;&#x3e;&#x3e; 24) &#x26; 0xff
    ];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.&#x3c;number&#x3e;} Byte representation
 */
LongPrototype.toBytes = function(le) {
    return le ? this.<span class="apidocCodeKeywordSpan">toBytesLE</span>() : this.toBytesBE();
}

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.&#x3c;number&#x3e;} Little endian byte representation
 */
LongPrototype.toBytesLE = function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toInt" id="apidoc.element.long.index.prototype.toInt">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toInt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toInt() {
    return this.unsigned ? this.low &#x3e;&#x3e;&#x3e; 0 : this.low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (this.isNegative()) { // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
        // We need to change the Long value before it can be negated, so we remove
        // the bottom-most digit in this base and then recurse to do the rest.
        var radixLong = fromNumber(radix),
            div = this.div(radixLong),
            rem1 = div.mul(radixLong).sub(this);
        return div.toString(radix) + rem1.<span class="apidocCodeKeywordSpan">toInt</span>().toString(radix);
    } else
        return &#x27;-&#x27; + this.neg().toString(radix);
}

// Do several (6) digits each time through the loop, so as to
// minimize the calls to the very expensive emulated div.
var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toNumber" id="apidoc.element.long.index.prototype.toNumber">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toNumber
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toNumber() {
    if (this.unsigned)
        return ((this.high &#x3e;&#x3e;&#x3e; 0) * TWO_PWR_32_DBL) + (this.low &#x3e;&#x3e;&#x3e; 0);
    return this.high * TWO_PWR_32_DBL + (this.low &#x3e;&#x3e;&#x3e; 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    else
        return this.neg().mul(multiplier).neg();
} else if (multiplier.isNegative())
    return this.mul(multiplier.neg()).neg();

// If both longs are small, use float multiplication
if (this.lt(TWO_PWR_24) &#x26;&#x26; multiplier.lt(TWO_PWR_24))
    return fromNumber(this.<span class="apidocCodeKeywordSpan">toNumber</span>() * multiplier.toNumber(), this.unsigned);

// Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
// We can skip products that would overflow.

var a48 = this.high &#x3e;&#x3e;&#x3e; 16;
var a32 = this.high &#x26; 0xFFFF;
var a16 = this.low &#x3e;&#x3e;&#x3e; 16;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toSigned" id="apidoc.element.long.index.prototype.toSigned">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toSigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x22;toSigned/Unsigned&#x22;: function(test) {
    var longVal = Long.fromNumber(-1, false);
    test.equal(longVal.toNumber(), -1);
    longVal = longVal.toUnsigned();
    test.equal(longVal.toNumber(), 0xFFFFFFFFFFFFFFFF);
    test.equal(longVal.toString(16), &#x27;ffffffffffffffff&#x27;);
    longVal = longVal.<span class="apidocCodeKeywordSpan">toSigned</span>();
    test.equal(longVal.toNumber(), -1);
    test.done();
},

&#x22;max_unsigned_sub_max_signed&#x22;: function(test) {
    var longVal = Long.MAX_UNSIGNED_VALUE.subtract(Long.MAX_VALUE).subtract(Long.ONE);
    test.equal(longVal.toNumber(), Long.MAX_VALUE.toNumber());
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toString" id="apidoc.element.long.index.prototype.toString">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toString
        <span class="apidocSignatureSpan">(radix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toString(radix) {
    radix = radix || 10;
    if (radix &#x3c; 2 || 36 &#x3c; radix)
        throw RangeError(&#x27;radix&#x27;);
    if (this.isZero())
        return &#x27;0&#x27;;
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return &#x27;-&#x27; + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = &#x27;&#x27;;
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() &#x3e;&#x3e;&#x3e; 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length &#x3c; 6)
                digits = &#x27;0&#x27; + digits;
            result = &#x27;&#x27; + digits + result;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
-----
The class is compatible with CommonJS and AMD loaders and is exposed globally as `dcodeIO.Long` if neither is available.

```javascript
var Long = require(&#x22;long&#x22;);

var longVal = new Long(0xFFFFFFFF, 0x7FFFFFFF);
console.log(longVal.<span class="apidocCodeKeywordSpan">toString</span>());
...
```

API
---

#### new Long(low, high=, unsigned=)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.toUnsigned" id="apidoc.element.long.index.prototype.toUnsigned">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>toUnsigned
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    } else if (divisor.isNegative())
        return this.div(divisor.neg()).neg();
    res = ZERO;
} else {
    // The algorithm below has not been made for unsigned longs. It&#x27;s therefore
    // required to take special care of the MSB prior to running it.
    if (!divisor.unsigned)
        divisor = divisor.<span class="apidocCodeKeywordSpan">toUnsigned</span>();
    if (divisor.gt(this))
        return UZERO;
    if (divisor.gt(this.shru(1))) // 15 &#x3e;&#x3e;&#x3e; 1 = 7 ; with divisor = 8 ; true
        return UONE;
    res = UZERO;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.long.index.prototype.xor" id="apidoc.element.long.index.prototype.xor">
        function <span class="apidocSignatureSpan">long.index.prototype.</span>xor
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
